# 错误处理和用户反馈机制验证

## 概述

本文档详细说明了图像API集成中的错误处理策略和用户反馈机制，确保系统在各种异常情况下都能提供良好的用户体验。

## 错误处理策略

### 1. API调用错误处理

#### 网络错误
```javascript
// 在 utils/image-analysis.js 中
async analyzeImage(imageData) {
  try {
    const response = await uni.request({
      url: API_CONFIG.url,
      method: 'POST',
      header: {
        'Authorization': API_CONFIG.token,
        'Content-Type': 'application/json'
      },
      data: { image: imageData },
      timeout: API_CONFIG.timeout
    });

    if (response.statusCode === 200 && response.data.result) {
      return this.processApiResponse(response.data);
    } else {
      throw new Error(`API响应异常: ${response.statusCode} ${response.data.errorMsg || '未知错误'}`);
    }
  } catch (error) {
    console.error('图像分析失败:', error);
    throw new Error(`图像分析失败: ${error.message || '网络错误'}`);
  }
}
```

#### 超时处理
- 设置30秒超时限制
- 超时后自动重试一次
- 重试失败后显示用户友好的错误信息

### 2. 图像处理错误处理

#### 图像转换错误
```javascript
// 在 pages/image-diagnose/index.vue 中
async imageToBase64(filePath) {
  return new Promise((resolve, reject) => {
    uni.getFileSystemManager().readFile({
      filePath: filePath,
      encoding: 'base64',
      success: (res) => {
        resolve(res.data);
      },
      fail: (error) => {
        reject(new Error('图像转换失败: ' + error.errMsg));
      }
    });
  });
}
```

#### 图像格式验证
```javascript
// 在 utils/image-analysis.js 中
validateImageData(imageData) {
  if (!imageData || typeof imageData !== 'string') {
    return false;
  }
  
  const base64Regex = /^data:image\/[a-zA-Z]+;base64,([A-Za-z0-9+/=]+)$/;
  const simpleBase64Regex = /^([A-Za-z0-9+/=]+)$/;
  
  return base64Regex.test(imageData) || simpleBase64Regex.test(imageData);
}
```

### 3. 数据处理错误处理

#### API响应格式验证
```javascript
// 在 utils/image-analysis.js 中
processApiResponse(apiResponse) {
  if (!apiResponse.result || !apiResponse.result.categories) {
    throw new Error('API响应数据格式不正确');
  }

  const categories = apiResponse.result.categories;
  
  // 找到置信度最高的类别
  const primaryCategory = categories.reduce((prev, current) => 
    (prev.score > current.score) ? prev : current
  );

  // 验证类别ID是否在映射范围内
  if (!STAGE_MAPPING[primaryCategory.id]) {
    throw new Error(`未知的类别ID: ${primaryCategory.id}`);
  }

  // ... 继续处理
}
```

## 用户反馈机制

### 1. 加载状态反馈

#### 诊断进行中
```javascript
// 在 pages/image-diagnose/index.vue 中
async startDiagnosis() {
  // 显示加载状态
  uni.showLoading({
    title: '正在诊断中...'
  });

  try {
    // ... 执行诊断逻辑
  } catch (error) {
    // ... 错误处理
  } finally {
    // 无论成功失败都隐藏加载状态
    uni.hideLoading();
  }
}
```

### 2. 错误提示反馈

#### 网络错误提示
```javascript
catch (error) {
  console.error('诊断失败:', error);
  uni.hideLoading();
  uni.showToast({
    title: '诊断失败，请重试',
    icon: 'error'
  });
}
```

#### 数据验证错误提示
```javascript
saveDiagnosis() {
  if (!this.diagnosisResult || !this.diagnosisResult.items) {
    uni.showToast({
      title: '没有可保存的诊断结果',
      icon: 'error'
    });
    return;
  }
  // ... 继续保存逻辑
}
```

### 3. 成功操作反馈

#### 保存成功提示
```javascript
saveDiagnosis() {
  // ... 验证和保存逻辑
  
  uni.showToast({
    title: '已保存到诊断历史',
    icon: 'success'
  });
  
  // ... 延迟重置状态
}
```

### 4. 操作确认反馈

#### 重置诊断确认
```javascript
resetDiagnosis() {
  uni.showModal({
    title: '确认重置',
    content: '确定要重置当前诊断吗？未保存的结果将丢失。',
    success: (res) => {
      if (res.confirm) {
        this.imageUrl = '';
        this.diagnosisResult = null;
        uni.showToast({
          title: '已重置',
          icon: 'success'
        });
      }
    }
  });
}
```

## 错误恢复机制

### 1. 网络错误恢复

#### 自动重试机制
```javascript
async analyzeImageWithRetry(imageData, maxRetries = 2) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await this.analyzeImage(imageData);
    } catch (error) {
      lastError = error;
      console.log(`第${i + 1}次尝试失败:`, error.message);
      
      // 如果不是网络错误，直接抛出
      if (!this.isNetworkError(error)) {
        throw error;
      }
      
      // 等待一段时间后重试
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
  
  throw lastError;
}

isNetworkError(error) {
  return error.message.includes('网络') || 
         error.message.includes('timeout') || 
         error.message.includes('Network');
}
```

### 2. 离线模式支持

#### 本地缓存机制
```javascript
// 在 utils/image-analysis.js 中添加
async getFromCache(imageHash) {
  try {
    const cacheData = uni.getStorageSync(`image_cache_${imageHash}`);
    if (cacheData) {
      const { timestamp, result } = JSON.parse(cacheData);
      // 缓存有效期24小时
      if (Date.now() - timestamp < 24 * 60 * 60 * 1000) {
        return result;
      }
    }
  } catch (error) {
    console.warn('读取缓存失败:', error);
  }
  return null;
}

async saveToCache(imageHash, result) {
  try {
    const cacheData = {
      timestamp: Date.now(),
      result: result
    };
    uni.setStorageSync(`image_cache_${imageHash}`, JSON.stringify(cacheData));
  } catch (error) {
    console.warn('保存缓存失败:', error);
  }
}
```

## 性能监控

### 1. 响应时间监控

```javascript
// 在 utils/image-analysis.js 中添加
async analyzeImageWithMetrics(imageData) {
  const startTime = Date.now();
  
  try {
    const result = await this.analyzeImage(imageData);
    const responseTime = Date.now() - startTime;
    
    console.log(`图像分析完成，响应时间: ${responseTime}ms`);
    
    // 如果响应时间过长，记录警告
    if (responseTime > 10000) {
      console.warn('图像分析响应时间过长:', responseTime);
    }
    
    return result;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    console.error(`图像分析失败，响应时间: ${responseTime}ms, 错误:`, error);
    throw error;
  }
}
```

### 2. 成功率统计

```javascript
// 在页面中添加统计逻辑
data() {
  return {
    diagnosticsStats: {
      total: 0,
      success: 0,
      failed: 0
    }
  };
},

methods: {
  async startDiagnosis() {
    this.diagnosticsStats.total++;
    
    try {
      // ... 执行诊断逻辑
      this.diagnosticsStats.success++;
    } catch (error) {
      this.diagnosticsStats.failed++;
      throw error;
    }
  }
}
```

## 验证测试用例

### 1. 网络错误测试

```javascript
// 测试场景：断网情况下进行诊断
async testNetworkError() {
  // 1. 关闭网络连接
  // 2. 尝试进行诊断
  // 3. 验证是否显示网络错误提示
  // 4. 验证是否进入错误处理流程
}
```

### 2. 超时测试

```javascript
// 测试场景：API响应超时
async testTimeoutError() {
  // 1. 模拟API响应超时
  // 2. 验证是否显示超时错误提示
  // 3. 验证是否尝试重试
}
```

### 3. 数据格式错误测试

```javascript
// 测试场景：API返回异常数据格式
async testDataFormatError() {
  // 1. 模拟API返回错误格式的数据
  // 2. 验证是否显示数据格式错误提示
  // 3. 验证是否进入错误处理流程
}
```

## 最佳实践

1. **始终显示加载状态**：让用户知道系统正在处理
2. **提供明确的错误信息**：告诉用户发生了什么问题
3. **提供恢复建议**：告诉用户可以做什么来解决问题
4. **记录详细日志**：便于调试和问题追踪
5. **优雅降级**：在服务不可用时提供基本功能
6. **性能监控**：持续监控关键指标

## 部署检查清单

- [ ] 所有错误情况都有对应的处理逻辑
- [ ] 用户反馈信息清晰易懂
- [ ] 错误日志记录完整
- [ ] 性能监控指标已设置
- [ ] 缓存机制已实现
- [ ] 重试机制已配置
- [ ] 离线模式已支持
- [ ] 测试用例已覆盖主要场景